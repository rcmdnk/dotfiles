" ==============================================
" Unused plugins {{{
" ==============================================

" Basic tools {{{

" vim-reunions {{{
" For asynchronous process
NeoBundle "osyo-manga/vim-reunions"
" }}} vim-reunions

" vim-quickrun {{{
" * Not necessary on GNU sceen...
NeoBundleLazy "thinca/vim-quickrun", { "autoload" : {
  \ "mappings" : [
  \ ["nxo", "<Plug>(quickrun)"]] }}
" }}}

" vim-singleton {{{
" Don't launch new vim instance
" * for Gvim heavy user?
NeoBundle "thinca/vim-singleton"
" }}}

" vimshell {{{
" Use shell in vim # not necessary on GNU screen
NeoBundleLazy 'Shougo/vimshell', {
  \ 'autoload' : { 'commands' : [ 'VimShell', "VimShellPop", "VimShellInteractive" ] }}
" }}} vimshell

" }}}

" Unite {{{
" Search and display information from arbitrary sources
call dein#add('Shougo/unite.vim', {
      \ 'on_cmd': ['Unite'],
      \ 'lazy': 1})

" Source for unite: mru
call dein#add('Shougo/neomru.vim', {'depdens': ['unite.vim']})

" Source for unite: mark
call dein#add('tacroe/unite-mark', {'depdens': ['unite.vim']})

" Source for unite: help
call dein#add('tsukkee/unite-help', {'depdens': ['unite.vim']})

" Source for unite: history/command, history/search
call dein#add('thinca/vim-unite-history', {'depdens': ['unite.vim']})

" Source for unite: history/yank
call dein#add('Shougo/neoyank.vim', {'depdens': ['unite.vim']})

" Source for unite: tag
call dein#add('tsukkee/unite-tag', {'depdens': ['unite.vim']})

" Source for unite: outline
call dein#add('Shougo/unite-outline', {'depdens': ['unite.vim']})

if s:dein_enabled && dein#tap('unite.vim')
  function! s:unite_my_settings()
    nmap <buffer><Esc> <Plug>(unite_exit)
    imap <buffer> jj      <Plug>(unite_insert_leave)
    "imap <buffer> <C-w>     <Plug>(unite_delete_backward_path)

    imap <buffer><expr> j unite#smart_map('j', '')
    imap <buffer> <TAB>   <Plug>(unite_select_next_line)
    imap <buffer> <C-w>     <Plug>(unite_delete_backward_path)
    imap <buffer> '     <Plug>(unite_quick_match_default_action)
    nmap <buffer> '     <Plug>(unite_quick_match_default_action)
    imap <buffer><expr> x
          \ unite#smart_map('x', '\<Plug>(unite_quick_match_choose_action)')
    nmap <buffer> x     <Plug>(unite_quick_match_choose_action)
    nmap <buffer> <C-z>     <Plug>(unite_toggle_transpose_window)
    imap <buffer> <C-z>     <Plug>(unite_toggle_transpose_window)
    imap <buffer> <C-y>     <Plug>(unite_narrowing_path)
    nmap <buffer> <C-y>     <Plug>(unite_narrowing_path)
    nmap <buffer> <C-j>     <Plug>(unite_toggle_auto_preview)
    nmap <buffer> <C-r>     <Plug>(unite_narrowing_input_history)
    imap <buffer> <C-r>     <Plug>(unite_narrowing_input_history)
    nnoremap <silent><buffer><expr> l
          \ unite#smart_map('l', unite#do_action('default'))

    let l:unite = unite#get_current_unite()
    if l:unite.buffer_name =~# '^search'
      nnoremap <silent><buffer><expr> r     unite#do_action('replace')
    else
      nnoremap <silent><buffer><expr> r     unite#do_action('rename')
    endif

    nnoremap <silent><buffer><expr> cd     unite#do_action('lcd')
    nnoremap <buffer><expr> S      unite#mappings#set_current_filters(
          \ empty(unite#mappings#get_current_filters()) ?
          \ ['sorter_reverse'] : [])

    " Runs 'split' action by <C-s>.
    imap <silent><buffer><expr> <C-s>     unite#do_action('split')
  endfunction
  autocmd MyAutoGroup FileType unite call s:unite_my_settings()
  " start with insert mode (can start narrow result in no time)
  let g:unite_enable_start_insert=1
  " window
  "let g:unite_enable_split_vertically=1
  let g:unite_split_rule='botright' " default topleft
  let g:unite_winheight=10          " default 20
  let g:unite_winwidth=60           " default 90
  let g:unite_data_directory=s:vimdir . '.cache/unite'

  " Unite prefix
  nnoremap [unite] <Nop>
  nmap <Leader>u [unite]

  " show buffer
  nnoremap <silent> [unite]b :Unite buffer<CR>
  " show files/directories with full path
  nnoremap <silent> [unite]f :Unite -buffer-name=files file<CR>
  " show frecursive file search
  "nnoremap <silent> [unite]f :<C-u>Unite file_rec/async:!<CR>
  " show register
  nnoremap <silent> [unite]r :Unite -buffer-name=register register<CR>
  " show lines of current file
  nnoremap <silent> [unite]l :Unite line<CR>
  " search (like ack.vim/ag.vim)
  nnoremap <silent> [unite]/ :Unite grep:.<CR>
  " show opened file history including current buffers
  if dein#tap('neomru.vim')
    nnoremap <silent> [unite]m :Unite file_mru<CR>
  else
    nnoremap <silent> [unite]m :UniteWithBufferDir -buffer-name=files buffer file_mru<CR>
  endif
  " mark
  if dein#tap('unite-mark')
    nnoremap <silent> [unite]M :Unite mark<CR>
  endif
  " help
  if dein#tap('unite-help')
    nnoremap <silent> [unite]h :Unite -start-insert help<CR>
  endif
  " history
  if dein#tap('vim-unite-history')
    nnoremap <silent> [unite]c :Unite history/command<CR>
    nnoremap <silent> [unite]S :Unite history/search<CR>
  endif
  " tag
  if dein#tap('unite-tag')
    nnoremap <silent> [unite]t :Unite tag<CR>
  endif
  " yank
  if dein#tap('neoyank.vim')
    nnoremap <silent> [unite]y :Unite history/yank<CR>
  elseif dein#tap('yankround.vim')
    nnoremap <silent> [unite]y :Unite yankround<CR>
  endif
  " snippet
  if dein#tap('neosnipet')
    nnoremap <silent> [unite]s :Unite neosnippet<CR>
  endif
endif
" }}} Unite


" Unite {{{
" sources {{{
" Source for unite: colorscheme
" * ':colorscheme' command is enough (Tab shows candidates)
NeoBundle 'ujihisa/unite-colorscheme'
" Source for unite: font
" * Only for gui
NeoBundle 'ujihisa/unite-font'
" Source for unite: fold
call dein#add('osyo-manga/unite-fold', {'depdens': ['unite.vim']})

" Source for unite: locate
call dein#add('ujihisa/unite-locate', {'depdens': ['unite.vim']})
" Source for unite: outline
call dein#add('Shougo/unite-outline', {'depdens': ['unite.vim']})

" coloscheme
if dein#tap("unite-colorscheme")
  nnoremap <silent> [unite]C :Unite colorscheme<CR>
endif
" locate
if dein#tap("unite-locate")
  nnoremap <silent> [unite]L :Unite locate<CR>
endif
" fold
if dein#tap("unite-fold")
  nnoremap <silent> [unite]F :Unite fold<CR>
endif
" }}}

" QuickBuf {{{
" bufffer management
" Unite is enough?

NeoBundle "QuickBuf"

if s:neobundle_enable && ! empty(neobundle#get("QuickBuf"))
  let g:qb_hotkey = "<Subleader>b"
endif
" }}} QuickBuf
" }}}

" Completion {{{
" neocomplcache {{{
"let g:completion = "Shougo/neocomplcache.vim"
if has('lua') && (( v:version == 703 && has('patch885')) || (v:version >= 704))
  let g:completion = "Shougo/neocomplete.vim"
  NeoBundleLazy g:completion, {
        \ "autoload": {"insert": 1 }}

  " look - display lines beginning with a given string, using with neocomplete/neocomplcache
  NeoBundleLazy "ujihisa/neco-look", {"depends": [g:completion],
        \ "autoload": {"insert": 1}}
  "NeoBundleLazy "mitsuse/kompl", {"depends": [g:completion]}
endif

if s:neobundle_enabled && ! empty(neobundle#get("neocomplcache.vim"))
  let g:acp_enableAtStartup = 1
  let g:neocomplcache_enable_startup = 1
  let g:neocomplcache_enable_smart_case = 1
  let g:neocomplcache_min_syntax_length = 3
  let g:neocomplcache_lock_buffer_name_pattern = '\*ku\*'
  let g:neocomplcache_text_mode_filetypes =
        \ {'text': 1, 'plaintex':1, 'javascript': 1,
        \  'mkd': 1, 'markdown': 1, 'perl': 1, 'html': 1}
endif
" }}}
" }}}

" Snippet {{{
" }}}

" Code syntax, tools for each language {{{

" Code Syntax {{{
" Use ale
" syntastic {{{
" (currently flake8 or other modules are installed independently)
call dein#add('vim-syntastic/syntastic')
NeoBundle "scrooloose/syntastic", {
  \ "build": {
  \   "windows": ["pip install flake8", "npm -g install coffeelint"],
  \   "cygwin": ["pip install flake8", "npm -g install coffeelint"],
  \   "mac": ["pip install flake8", "npm -g install coffeelint"],
  \   "unix": ["pip install flake8", "npm -g install coffeelint"] }}

if s:dein_enabled && dein#tap('syntastic')
  " Disable automatic check at file open/close
  let g:syntastic_check_on_open=0
  let g:syntastic_check_on_wq=0
  " C
  let g:syntastic_c_check_header = 1
  " C++
  let g:syntastic_cpp_check_header = 1
  " Java
  let g:syntastic_java_javac_config_file_enabled = 1
  let g:syntastic_java_javac_config_file = '$HOME/.syntastic_javac_config'
  " python
  let g:syntastic_python_checkers = ['flake8']
  " ruby
  let g:syntastic_ruby_checkers = ['rubocop']
  " args for shellcheck
  let g:syntastic_sh_shellcheck_args = "-e SC1090,SC2059,SC2155,SC2164"
endif
"}}} syntastic

" vim-watchdogs {{{
" Use ale
NeoBundle "osyo-manga/vim-watchdogs", {
    \ "depends": ["Shougo/vimproc", "thinca/vim-quickrun",
                 \"dannyob/quickfixstatus",
                 \"osyo-manga/shabadou.vim", "cohama/vim-hier",
                 \"KazuakiM/vim-qfsigns"]}

if s:dein_enabled && dein#tap("vim-watchdogs")
  let g:watchdogs_check_BufWritePost_enable = 1
  let g:watchdogs_check_CursorHold_enable = 1
  if !exists("g:quickrun_config")
    let g:quickrun_config = {}
  endif
  let g:quickrun_config["watchdogs_checker/_"] = {
  \ "outputter/quickfix/open_cmd" : "",
  \ "runner/vimproc/updatetime" : 50,
  \ "hook/qfsigns_update/enable_exit": 1,
  \ "hook/qfsigns_update/priority_exit": 3,
  \}
  let s:flake8 = system('flake8 --version 2>/dev/null')
  if s:flake8 != ""
    let g:quickrun_config["python/watchdogs_checker"] = {
    \ "type" : "watchdogs_checker/flake8"
    \}
  endif
  call watchdogs#setup(g:quickrun_config)
endif
"}}} vim-watchdogs

" neomake{{{
call dein#add('neomake/neomake')
call dein#add('benjie/neomake-local-eslint.vim')

if s:dein_enabled && dein#tap('neomake')
  autocmd MyAutoGroup BufWritePost * Neomake

  autocmd MyAutoGroup VimEnter,ColorScheme * hi NeomakeInfoSign term=bold ctermfg=0 ctermbg=6 gui=bold guifg=Blue guibg=coral
  autocmd MyAutoGroup VimEnter,ColorScheme * hi link NeomakeInfo NeomakeInfoSign
  autocmd MyAutoGroup VimEnter,ColorScheme * hi NeomakeWarningSign term=standout ctermfg=0 ctermbg=11 guifg=Black guibg=orange
  autocmd MyAutoGroup VimEnter,ColorScheme * hi link NeomakeWarning NeomakeWarningSign
  autocmd MyAutoGroup VimEnter,ColorScheme * hi NeomakeErrorSign term=reverse ctermfg=15 ctermbg=9 guifg=White guibg=Red
  autocmd MyAutoGroup VimEnter,ColorScheme * hi link NeomakeError NeomakeErrorSign

  let g:neomake_javascript_enabled_makers = ['eslint']

  let g:neomake_error_sign = {'text': 'e', 'texthl': 'NeomakeErrorSign'}
  let g:neomake_warning_sign = {
      \   'text': 'w',
      \   'texthl': 'NeomakeWarningSign',
      \ }
  let g:neomake_message_sign = {
       \   'text': 'm',
       \   'texthl': 'NeomakeMessageSign',
       \ }
  let g:neomake_info_sign = {'text': 'i', 'texthl': 'NeomakeInfoSign'}
endif
"}}} neomake

" }}}

" vim-hier{{{
if s:dein_enabled && dein#tap("vim-hier")
  highlight qf_error ctermfg=255 ctermbg=1
  highlight qf_warning ctermfg=255 ctermbg=3
  highlight qf_info ctermfg=255 ctermbg=2
  let g:hier_highlight_group_qf   = 'qf_error'
  let g:hier_highlight_group_qfw  = 'qf_warning'
  let g:hier_highlight_group_qfi  = 'qf_info'
endif
" }}} vim-hier

" Tags {{{
" taglist{{{
" Use tagbar instead (appearance seems almost same)
" but taglist failed to make tags...?
NeoBundle "taglist.vim"
if s:neobundle_enable && ! empty(neobundle#get("taglist.vim"))
  set tags=tags
  "let Tlist_Ctags_Cmd = "/usr/bin/ctags"
  let Tlist_Show_One_File = 1
  let Tlist_Use_Right_Window = 1
  let Tlist_Exit_OnlyWindow = 1
  nnoremap <silent> <leader>l :TlistToggle<CR>
endif
"}}} taglist

" ctags{{{
" make ctags for current file
NeoBundle "ctags.vim"
" }}}
" }}}

" c++ {{{
" clang_complete{{{
NeoBundleLazy "Rip-Rip/clang_complete", {
  \"autoload" : { "filetypes" : ["c", "cpp"] }}

if s:neobundle_enable && ! empty(neobundle#get("lang_complete"))
  "g:clang_use_library = 1
  "g:clang_complete_auto = 0
endif
" }}} clang_complete
" }}}

" JavaScript {{{
" * Something wrong at buffer change
NeoBundle "marijnh/tern_for_vim"
"}}}

" Python {{{
" Python syntax
" use "hynek/vim-python-pep8-indent", instead
NeoBundle "mitsuhiko/vim-python-combined"

" Python syntax
" Syntastics or watch-dogs is enough.
NeoBundle "nvie/vim-flake8"

" jedi-vim{{{
" jedi-vim
" Python autocompletion
" Show error of
"     ImportError: No module named os
" when PYTHONPATH was changed (updated for brew-pip on Mac)...
" this filetypes are unnecessary, neither, as they are loaded only when python file is loaded.
NeoBundleLazy "davidhalter/jedi-vim", {
    \ "autoload": { "filetypes": [ "python", "python3", "djangohtml"] }}
if s:dein_enabled && dein#tap("jedi-vim")
  let g:jedi#auto_initialization = 1
  let g:jedi#auto_vim_configuration = 1

  nnoremap [jedi] <Nop>
  xnoremap [jedi] <Nop>
  nmap <Leader>j [jedi]
  xmap <Leader>j [jedi]

  let g:jedi#completions_command = "<C-N>"
  let g:jedi#goto_assignments_command = "[jedi]g"
  let g:jedi#goto_definitions_command = "[jedi]d"
  let g:jedi#documentation_command = "[jedi]K"
  let g:jedi#rename_command = "[jedi]r"
  let g:jedi#usages_command = "[jedi]n"
  let g:jedi#popup_select_first = 0
  let g:jedi#popup_on_dot = 0

  autocmd MyAutoGroup FileType python setlocal completeopt-=preview

  " w/ neocomplete
  if dein#tap("neocomplete.vim")
    autocmd MyAutoGroup FileType python setlocal omnifunc=jedi#completions
    let g:jedi#completions_enabled = 0
    let g:jedi#auto_vim_configuration = 0
    let g:neocomplete#force_omni_input_patterns.python =
    \ '\%([^. \t]\.\|^\s*@\|^\s*from\s.\+import \|^\s*from \|^\s*import \)\w*'
    " alternative pattern: '\h\w*\|[^. \t]\.\w*'
  endif
endif
" }}} jedi-vim

" virtual env (not used)
NeoBundle "jmcantrell/vim-virtualenv"
" }}} Python

" Markdown {{{
" vim-quick-run-markdown-gfm {{{
" need gfm GitHub Flavored Markdown...?
NeoBundleLazy "superbrothers/vim-quickrun-markdown-gfm", {
      \"depends":
      \  ["tryu/open-browser.vim","thinca/vim-quickrun", "mattn/webapi-vim"]}
if s:neobundle_enabled && ! empty(neobundle#get("quickrun"))
                       &&! empty(neobundle#get("vim-quickrun-markdown-gfm"))
  let g:quickrun_config = {
  \   'markdown': {
  \     'type': 'markdown/gfm',
  \     'outputter': 'browser'
  \   }
  \ }
endif
"}}}

" Syntax {{{
"NeoBundle "plasticboy/vim-markdown"
"NeoBundle "tpope/vim-markdown"
"NeoBundle "hallison/vim-markdown"
"NeoBundle "Markdown"
" }}}

" jekyll.vim{{{
" these commands are not necessary to be done in vim
NeoBundle "csexton/jekyll.vim"

if s:neobundle_enable && ! empty(neobundle#get("jekyll.vim"))
  let g:jekyll_path = "~/Dropbox/05_WebService/octopress/source/"
endif
"}}} jekyll.vim

" octopress {{{
" Highlight for octopress
" * vim-markdown is rather good (no syntax for jekyll?)
NeoBundle "tangledhelix/vim-octopress"

if s:neobundle_enable && ! empty(neobundle#get("vim-octopress"))
  autocmd BufNewFile,BufRead *.md,*.textile set filetype=octopress
endif
"}}} octopress

" previm {{{ not necessary in vim (markdown is useful as it can be easily recognized as "TEXT")
" Markdown preview
if ( has("win32unix") || has ("win64unix") ||
      \has("mac") || has ("gui_macvim"))
  NeoBundleLazy "kannokanno/previm", {
        \"autoload": {"commands" : ["PrevimOpen"]}}
else
  NeoBundleLazy "kannokanno/previm", {
        \ "depends": ["tryu/open-browser.vim"],
        \"autoload": {"commands" : ["PrevimOpen"]}}
endif
if s:neobundle_enabled && ! empty(neobundle#get("previm"))
  if ( has("win32unix") || has ("win64unix"))
    " cygwin
    let g:previm_open_cmd = "cygstart"
  elseif ( has("mac") || has ("gui_macvim"))
    " mac
    let g:previm_open_cmd = "open"
  endif
endif

"}}} previm

" }}}

" Ruby {{{
  " Ruby completion " doesn't work...?
  " Neocomplete is enough?
  NeoBundle "osyo-manga/vim-monster"

  if s:neobundle_enabled && ! empty(neobundle#get("vim-monster"))
    if ! empty(neobundle#get("neocomplete.vim")) && !empty(neobundle#get("vimproc.vim"))
      " Set async completion.
      let g:monster#completion#rcodetools#backend = "async_rct_complete"

      " Use neocomplete.vim
      let g:neocomplete#sources#omni#input_patterns = {
      \   "ruby" : '[^. *\t]\.\w*\|\h\w*::',
      \}
    endif
  endif
"}}}

" AutoHotkey {{{
" Default file ...share/vim/vim80/syntax/autohotkey.vim has better (and newer) definitions.
call dein#add('vim-scripts/autohotkey-ahk')
"}}}

" Latex {{{
" Automatic LaTeX Plugins
call dein#add('coot/atp_vim')
" }}}
" }}} Code syntax, tools for each language

" View {{{
" Color scheme {{{
NeoBundle "ujihisa/unite-colorscheme"
NeoBundle "tomasr/molokai"
colorscheme molokai
NeoBundle "nanotech/jellybeans.vim"
NeoBundle "altercation/vim-colors-solarized"
NeoBundle "vim-scripts/newspaper.vim"
NeoBundle "w0ng/vim-hybrid"
NeoBundle "noahfrederick/vim-hemisu"
NeoBundle "google/vim-colorscheme-primary"

"colorscheme blue
" }}}

" rainbow_parentheses {{{
" Highlight bracket
" * Sometime conflicts with other file syntax
" * (e.g. markdown syntax for URL)
NeoBundle "kien/rainbow_parentheses.vim"

if s:neobundle_enable && ! empty(neobundle#get("rainbow_parentheses.vim"))
  "let g:rbpt_colorpairs = [
  "    \ ['brown',       'RoyalBlue3'],
  "    \ ['Darkblue',    'SeaGreen3'],
  "    \ ['darkgray',    'DarkOrchid3'],
  "    \ ['darkgreen',   'firebrick3'],
  "    \ ['darkcyan',    'RoyalBlue3'],
  "    \ ['darkred',     'SeaGreen3'],
  "    \ ['darkmagenta', 'DarkOrchid3'],
  "    \ ['brown',       'firebrick3'],
  "    \ ['gray',        'RoyalBlue3'],
  "    \ ['black',       'SeaGreen3'],
  "    \ ['darkmagenta', 'DarkOrchid3'],
  "    \ ['Darkblue',    'firebrick3'],
  "    \ ['darkgreen',   'RoyalBlue3'],
  "    \ ['darkcyan',    'SeaGreen3'],
  "    \ ['darkred',     'DarkOrchid3'],
  "    \ ['red',         'firebrick3'],
  "    \ ]
  let g:rbpt_loadcmd_toggle = 0
  let g:rbpt_max = 16
  au VimEnter * RainbowParenthesesToggle
  au Syntax * RainbowParenthesesLoadRound
  au Syntax * RainbowParenthesesLoadSquare
  au Syntax * RainbowParenthesesLoadBraces
endif
" }}} rainbow_parentheses

" for hl_matchit {{{
" Vim plugin to highlight matchit.vim
" # Make it too slow especially for files which have many brackets
" # It can match such "if" in vimrc
" # But it seems too much...
NeoBundle "vimtaku/hl_matchit.vim"

if s:neobundle_enable && ! empty(neobundle#get("hl_matchit.vim"))
  let g:hl_matchit_enable_on_vim_startup = 1
  let g:hl_matchit_hl_groupname = 'Title'
  let g:hl_matchit_allow_ft_regexp = 'html\|vim\|ruby\|sh'
endif
" }}} hl_matchit

" undotree {{{
" Another undo, need vim7.3+patch005
" Use gundo instead
NeoBundle "mbbill/undotree"

if s:neobundle_enable && ! empty(neobundle#get("undotree"))
  nmap <Leader>U :UndotreeToggle<CR>
  let g:undotree_SetFocusWhenToggle = 1
  let g:undotree_SplitLocation = "topleft"
  let g:undotree_SplitWidth = 35
  let g:undotree_diffAutoOpen = 1
  let g:undotree_diffpanelHeight = 25
  let g:undotree_RelativeTimestamp = 1
  let g:undotree_TreeNodeShape = "*"
  let g:undotree_HighlightChangedText = 1
  let g:undotree_HighlightSyntax = "UnderLined"
endif
" }}}

" vim-pcompleteowerline {{{
" Cool Status Line
" * Use lightline
NeoBundle "Lokaltog/vim-pcompleteowerline"
" }}}

" vim-airline{{{
" Another status line
" * Use lightlin
NeoBundle "bling/vim-airline"

" inu/nuco
"NeoBundle "osyo-manga/vim-airline-inu"
"NeoBundle "osyo-manga/vim-airline-nuko"

if s:neobundle_enable && ! empty(neobundle#get("vim-airline"))
  let g:airline_left_sep=''
  let g:airline_right_sep=''
  let g:airline_inactive_collapse=1
  let g:airline_theme="bubblegum"
  let g:airline_section_z="%4l/%L:%3c"
endif
"}}} vim-airline

" vim-insert-linenr {{{
" Highlight line number
" * Line number is not used...
NeoBundle 'cohama/vim-insert-linenr'
" }}}

" Visual-Mark {{{
" visualize marks
" * unite + unite-mark is an alternative
NeoBundle "Visual-Mark"

if s:neobundle_enable && ! empty(neobundle#get("Visual-Mark"))
  " Visual Mark prefix
  nnoremap [vmark] <Nop>
  nmap <Leader>v [vmark]
  nmap <silent> [vmark]v <Plug>Vm_toggle_sign
  nmap <silent> [vmark]j <Plug>Vm_goto_next_sign
  nmap <silent> [vmark]k <Plug>Vm_goto_prev_sign
  " submot doesn't work?
  "if ! empty(neobundle#get("vim-submode"))
  "  call submode#enter_with("visualmark", "n", "", ",vj", "<Plug>Vm_goto_next_sign")
  "  call submode#enter_with("visualmark", "n", "", ",vk", "<Plug>Vm_goto_prev_sign")
  "  call submode#map("visualmark", "n", "", ",vj", "<Plug>Vm_goto_next_sign")
  "  call submode#map("visualmark", "n", "", ",vk", "<Plug>V<Leader>m_goto_prev_sign")
  "  call submode#map("visualmark", "n", "", "vj", "<Plug>Vm<Leader>_goto_next_sign")
  "  call submode#map("visualmark", "n", "", "vk", "<Plug>Vm_goto_prev_sign")
  "  call submode#map("visualmark", "n", "", "j", "<Plug>Vm_goto_next_sign")
  "  call submode#map("visualmark", "n", "", "k", "<Plug>Vm_goto_prev_sign")
  "endif
endif
" }}} surround.vim

" Changed {{{
" Displays signs on changed lines, since last save
" -> use DiffOrig, if necessary
NeoBundleLazy "Changed", {
  \ "autoload": {"commands": ["Changed"]}}
}
" }}}

" File Explorer {{{
" * Use SrcExpl

" ctrlp {{{
NeoBundle "kien/ctrlp.vim"
if s:neobundle_enable && ! empty(neobundle#get("ctrlp.vim"))
  "let g:ctrlp_map = "<c-p>"
endif
"}}} ctrlp

NeoBundle "scrooloose/nerdtree"
NeoBundle "trinity.vim"
NeoBundle "The-NERD-tree"
NeoBundle "Source-Explorer-srcexpl.vim"
NeoBundle "mru.vim"
" }}}

" vim-better-whitespace {{{
" Could be useful if 'set cursorline' is used, and highlight for background is used.
NeoBundle "ntpeters/vim-better-whitespace"
" }}}

" }}} View

" Version Control System {{{
" gitgutter{{{
" Show added/deleted/modified line for git
" * Use signify, which can do for svn or others in addiiton to git
NeoBundleLazy "airblade/vim-gitgutter", {
  \ "autoload": { "commands": ["GitGutterEnable","GitGutterToggle"]}}

if s:neobundle_enable && ! empty(neobundle#get("vim-gitgutter"))
  nnoremap <Leader>g :GitGutterToggle<CR>
endif
"}}} gitgutter

" signify{{{
" Show added/deleted/modified lines for several version control system
" vcscommand is enough
" if you want to show marks always, it is useful, though.
call dein#add('mhinz/vim-signify', {
      \ 'on_cmd': ['SignifyToggle'],
      \ 'lazy': 1})
if s:dein_enabled && dein#tap("vim-signify")
  let g:signify_disable_by_default = 1
  let g:signify_cursorhold_normal = 1
  let g:signify_cursorhold_insert = 1
  nmap <Leader>gj <Plug>(signify-next-jump)
  nmap <Leader>gk <Plug>(signify-prev-jump)
  nnoremap <Leader>gt :SignifyToggle<CR>
  nnoremap <Leader>gh :SignifyToggleHighlight<CR>
endif
"}}} signify

" For git/svn status, log {{{
call dein#add('hrsh7th/vim-versions.git', {
      \ 'depends': ['unite.vim'],
      \ 'on_cmd': ['UniteVersions'],
      \ 'lazy': 1})
" }}}

" vim-rooter{{{
" Change current directory to root, for git/svn, etc...
" not used
call dein#add('airblade/vim-rooter')
if s:dein_enabled && dein#tap("vim-rooter")
  " Default: move to root directory by <Leader>cd or :Rooter

  " Change only current window's directory
  let g:rooter_use_lcd = 1
  " Do not automatically change the directory
  let g:rooter_manual_only = 1
  " Stop the automatic change (some files are )
  let g:rooter_manual_only = 1
  " files/directories for the root directory
  let g:rooter_patterns = ['tags', '.git', '.git/', '_darcs/', '.hg/', '.bzr/', 'Makefile', 'GNUMakefile', 'GNUmakefile', '.svn/']
endif
"}}} vim-rooter
" }}} Version Control System

" Selection {{{
" wildfire {{{
call dein#add('gcmt/wildfire.vim')
if s:dein_enabled && dein#tap('wildfire.vim')
  "let g:wildfire_objects = {
  "      \ '*' : ['iw', "i'", "a'", 'i"', 'a"', 'i)', 'a)', 'i]', 'a]', 'i}', 'a}', 'i>', 'a>', 'ip', 'ap', 'it', 'at'],
  "      \ }
  let g:wildfire_objects = ['iw', "i'", "a'", 'i"', 'a"', 'i)', 'a)', 'i]', 'a]', 'i}', 'a}', 'i>', 'a>', 'ip', 'ap', 'it', 'at']

  " This selects the next closest text object.
  map <RETURN> <Plug>(wildfire-fuel)

  " This selects the previous closest text object.
  vmap <BS> <Plug>(wildfire-water)
endif
" }}}

" }}}

" Search {{{
" vim-seek {{{
" Jump to letters (two letters) after "s"
" * / (search) or easymoting can be alternatives...
NeoBundle "goldfeld/vim-seek"
" }}}

" incsearch {{{
" Improved incremental searching (default incsearch shows only the next one.)
" The main feature, highlighting all incremental search match words, was included in Vim itself from 8.0.1238.
call dein#add('haya14busa/incsearch.vim')
if s:dein_enabled && dein#tap('incsearch.vim')
  map / <Plug>(incsearch-forward)
  map ? <Plug>(incsearch-backward)
  map g/ <Plug>(incsearch-stay)
  let g:incsearch#magic = '\v'
endif
" }}} incsearch
" }}}

" Edit {{{
" operator {{{
" replace is used
" not use sort, reverse, surround
NeoBundle "kana/vim-operator-user"
NeoBundle "kana/vim-operator-replace"
"NeoBundle 'emonkak/vim-operator-sort'
"NeoBundle 'tyru/operator-reverse.vim'
"NeoBundle "rhysd/vim-operator-surround" " -> use vim-surround
if s:dein_enabled && dein#tap("vim-operator-user")
  nnoremap [oper] <Nop>
  nm <Leader>o [oper]
  if s:dein_enabled && dein#tap("vim-operator-sort")
    map [oper]s <Plug>(operator-sort)
  endif
  if s:dein_enabled && dein#tap("operator-reverse.vim")
    map [oper]r  <Plug>(operator-reverse-text)
  endif
endif
" }}} operator

" Align {{{
" Align codes
" http://www.drchip.org/astronaut/vim/align.html#Examples
" * Use 'h1mesuke/vim-alignta' instead
NeoBundle "Align"
" }}} Align

" Table {{{
" There are tabular and Alignta.
call dein#add('dhruvasagar/vim-table-mode')
" }}}

" vim-smartchr {{{
" Toggle insert words
" * Example is for ' = ', ' == ', '='
" * maybe it can be used more useful way, but now it it not used.
NeoBundle "kana/vim-smartchr"

if s:neobundle_enable && ! empty(neobundle#get("vim-smartchr"))
  inoremap <buffer><expr> = smartchr#one_of(' = ', ' == ', '=')
endif
" }}} vim-smartchr

" YankRing {{{
" Easy to use history of yanks (see below settings)
" * Strange behavior (couse it map all y/d/c/x)
" Use yankround, instead.vim
NeoBundle "vim-scripts/YankRing.vim"

if s:neobundle_enable && ! empty(neobundle#get("YankRing.vim"))
  nnoremap <Leader>y :YRShow<CR>
  " avoid to store single letter to normal register
  let g:yankring_history_dir=g:vimdir
  "let g:yankring_n_keys = 'Y D' " Y D x X
  "let g:yankring_enabled=0 " 1
  let g:yankring_max_history=50 " 100
  let g:yankring_max_display=50 " 500
  "let g:yankring_ignore_duplicate=0 " 1
  let g:yankring_dot_repeat_yank=1
  let g:yankring_clipboard_monitor=0 " 1
  let g:yankring_min_element_length=2 " 1, :skip all single letter copy
  "let g:yankring_persist=0 " 1
  "let g:yankring_share_between_instances=0 " 1
  "let g:yankring_window_use_separate=0 " 1
  "let g:yankring_window_use_horiz=0
  "let g:yankring_window_auto_close=0 " 1
  let g:yankring_window_width=50 " 30
  "let g:yankring_window_use_right=0 " 1
  "let g:yankring_window_increment=15 " 1
  let g:yankring_manage_numbered_reg = 1 " 0
  "let g:yankring_paste_check_default_register = 0 "1

  " for warning :The yankring can only persist if the viminfo setting has a !
  "set viminfo+=!
endif
" }}} YankRing

" vim-yankstack {{{
" Yank stack (similar as YankRing)
" * same as YankRing, it map y/d/c/x...
NeoBundle "maxbrunsfeld/vim-yankstack"

if s:neobundle_enable && ! empty(neobundle#get("vim-yankstack"))
  nmap <M-p> <Plug>yankstack_substitute_older_paste
  nmap <M-n> <Plug>yankstack_substitute_newer_paste
endif
" }}} vim-yankstack

" yanktmp {{{
" Use yanks in different processes (see below settings)
" * It can yank only a line
" * replaced by own setting
NeoBundle "yanktmp.vim"

if s:neobundle_enable && ! empty(neobundle#get("yanktmp.vim"))
  let g:yanktmp_file = $HOME."/.vim/vimyanktmp"

  " yanktmp prefix
  noremap [yanktmp] <Nop>
  map s [yanktmp]

  " show buffer
  noremap <silent> [yanktmp]y :call YanktmpYank()<CR>
  noremap <silent> [yanktmp]p :call YanktmpPaste_p()<CR>
  noremap <silent> [yanktmp]P :call YanktmpPaste_P()<CR>
endif
" }}} yanktmp

" vim-smartinput {{{
" smart input
" * Can't use for repeat
NeoBundle "kana/vim-smartinput"

if s:neobundle_enable && ! empty(neobundle#get("vim-smartinput"))
  " Put/Remove space at first in bracket
  call smartinput#map_to_trigger('i', '<Space>', '<Space>', '<Space>')
  call smartinput#define_rule({
    \'at'    : '(\%#)',
    \'char'  : '<Space>',
    \'input' : '<Space><Space><Left>',
    \})
  call smartinput#define_rule({
    \'at'    : '( \%# )',
    \'char'  : '<BS>',
    \'input' : '<Del><BS>',
    \})

  " Add ; for c++ class/struct/enum
  call smartinput#define_rule({
    \'at'       : '\%(\<struct\>\|\<class\>\|\<enum\>\)\s*\w\+.*\%#',
    \'char'     : '{',
    \'input'    : '{};<Left><Left>',
    \'filetype' : ['cpp'],
    \})

  " * Replaced by: nnoremap <Leader><Space>  :%s/<Space>\+$//g<CR><C-o>
  call smartinput#define_rule({
  \   'at': '\s\+\%#',
  \   'char': '<CR>',
  \   'input': '<C-o>:call setline('.', substitute(getline('.'), '\\s\\+$', '', ''))<CR><CR>',
  \   })
endif
" }}} vim-smartinput

" vim-smartword {{{
" smart word
" * If it is not used so much (as capital W/B...),
" * it is better to use original one...
NeoBundle 'kana/vim-smartword'

if s:neobundle_enable && ! empty(neobundle#get("vim-smartword"))
  " Use W/B/E/gE, such w is not useful to map here
  " especially for text object treatment, such 'cw'.
  map W  <Plug>(smartword-w)
  map B  <Plug>(smartword-b)
  map E  <Plug>(smartword-e)
  map gE  <Plug>(smartword-ge)
  " original keys ('\' is not a <leader> for now)
  noremap <Subleader>W  W
  noremap <subleader>B  B
  noremap <subleader>E  E
  noremap <subleader>gE  gE
endif
" }}} vim-smartword

" Auto bracket closing {{{
NeoBundle "cohama/lexima.vim"
NeoBundle "seletskiy/vim-autosurround"
if s:dein_enabled && dein#tap("vim-autosurround")
  inoremap  ( (<C-O>:call AutoSurround(")")<CR>
endif
" }}}

" vim-surround {{{
" Each to change surround
" * use original surround.vim
NeoBundle "anyakichi/vim-surround"
if s:neobundle_enable && (! empty(neobundle#get("surround.vim")) || ! empty(neobundle#get("vim-surround")))
  "
endif

" vim-operator-flashy {{{
" highlight copied region
" There seems some conflicts with other color settings.
call dein#add('haya14busa/vim-operator-flashy')
if s:dein_enabled && dein#tap('vim-operator-flashy')
  map y <Plug>(operator-flashy)
  nmap Y <Plug>(operator-flashy)$
endif
" }}} vim-operator-flashy

" }}}

" savevers {{{
" File Edit History
" * Make several backup file named *.clean, to follow history easily.
" * Not so useful when persistent_undo is enabled,
" * but rather it makes things complex as it makes too many '.clean' files...
NeoBundle "savevers.vim"

if s:neobundle_enable && ! empty(neobundle#get("savevers.vim"))
  set patchmode=.clean
  set backup
  let savevers_types = "*"
  let savevers_dirs = &backupdir
  let versdiff_no_resize=1
  nmap <silent> <F5> :VersDiff -<cr>
  nmap <silent> <F6> :VersDiff +<cr>
  nmap <silent> <F8> :VersDiff -c<cr>
endif
" }}}

" switch {{{
" switch
NeoBundle "AndrewRadev/switch.vim"

if s:dein_enabled && dein#tap("switch.vim")
  nnoremap - :Switch<cr>
endif
"}}} switch

" restart {{{
" For Gvim
NeoBundle "tyru/restart.vim"
"}}}

" vim-auto-save {{{
" * normally, it is better to save by hand.
"NeoBundle "vim-scripts/vim-auto-save"

if s:neobundle_enable && ! empty(neobundle#get("vim-auto-save"))
  " auto save interval is 'updatetime'(=200 ms as default)
  let g:auto_save = 1

endif
" }}} vim-auto-save

" rabbit-ui.vim {{{
" Especially for CSV editing
" Too slow...
call dein#add('rbtnn/rabbit-ui.vim')

if s:dein_enabled && dein#tap("rabbit-ui.vim")
  function! s:edit_csv(path)
    call writefile(map(rabbit_ui#gridview(
          \ map(readfile(expand(a:path)),'split(v:val,",",1)')),
          \ "join(v:val, ',')"), expand(a:path))
  endfunction
  command! -nargs=1 -complete=file EditCSV  :call <sid>edit_csv(<q-args>)
endif
"}}} rabbit-ui.vim

" splitjoin {{{
" Code modification: one-liner <-> multi-line
" not so expected.
call dein#add('AndrewRadev/splitjoin.vim', {
      \ 'on_cmd': ['SplitjoinJoin', 'SplitjoinJoin'],
      \ 'lazy': 1})
if s:dein_enabled && dein#tap("splitjoin.vim")
  let g:splitjoin_split_mapping = ''
  let g:splitjoin_join_mapping = ''
  nmap <Leader><Leader>j :SplitjoinJoin<CR>
  nmap <Leader><Leader>s :SplitjoinSplit<CR>
endif
" }}} splitjoin

" vim-expand-region {{{
" wildfire.vim is similar one
" vim-expand-region make it very slow when it is called at the first time...?
call dein#add('terryma/vim-expand-region')

if s:dein_enabled && dein#tap("vim-expand-region")
  let g:expand_region_text_objects = {
        \ 'iw'  :1,
        \ 'iW'  :1,
        \ 'i"'  :1,
        \ 'i''' :1,
        \ 'i]'  :1,
        \ 'ib'  :1,
        \ 'iB'  :1,
        \ 'il'  :1,
        \ 'ip'  :1,
        \ 'ie'  :1,
        \ }
  if dein#tap("vim-submode")
    call submode#enter_with('expand-region', 'nv', 'r', '<Leader>e', '<Plug>(expand_region_expand)')
    call submode#map('expand-region', 'nv', 'r', 'e', '<Plug>(expand_region_expand)')
    call submode#map('expand-region', 'nv', 'r', 'w', '<Plug>(expand_region_shrink)')
  endif
endif
" }}} vim-expand-region

" }}}

" Move {{{
" vim-easymotion{{{
" Easymotion
" Search & jump is enough
call dein#add('easymotion/vim-easymotion', {
      \ 'on_map': ['<Plug>(easymotion-sn)', '<Plug>(easymotion-bd-W)',
      \            '<Plug>(easymotion-bd-w)'],
      \ 'lazy': 1})

if s:dein_enabled && dein#tap('vim-easymotion')
  let g:EasyMotion_do_mapping=0
  let g:EasyMotion_grouping=1
  let g:EasyMotion_enter_jump_first=1
  let g:EasyMotion_space_jump_first=1
  let g:EasyMotion_smartcase=1
  let g:EasyMotion_use_upper=1
  let g:EasyMotion_keys='hjklasdfgyuiopqwertnmzxcvb'
  hi EasyMotionTarget ctermbg=none ctermfg=red
  hi EasyMotionShade  ctermbg=none ctermfg=blue

  map S <Plug>(easymotion-sn)
  map <Leader>f <Plug>(easymotion-bd-W)
  "nmap <Leader>f <Plug>(easymotion-overwin-w)
endif
" }}} vim-easymotion

" clever-f {{{
" Can use f instead of ;, after fx move
" Can move even to other lines
" * annoying at making macros...
NeoBundle "rhysd/clever-f.vim"
"}}}
" }}}

" Check language, web source {{{
" LanguageTool{{{
" Use vim-grammarous
NeoBundleLazy "vim-scripts/LanguageTool", {
      \  "autoload" : {"commands": ["LanguageToolCheck"] }}
if s:neobundle_enabled && ! empty(neobundle#get("LanguageTool"))
  " jar file settings
  let s:languagetool_version="3.2"
  "let s:languagetool_version="2.1"
  let s:languagetool_zip="LanguageTool-".s:languagetool_version.".zip"
  let s:languagetool_download=
        \"http://www.languagetool.org/download/".s:languagetool_zip
  let s:languagetool_parent_dir=g:vimdir."/languagetool/"
  let s:languagetool_dir=s:languagetool_parent_dir."/LanguageTool-"
        \.s:languagetool_version."/"
  let s:languagetool_v_file=s:languagetool_dir."/version_in_vim"

  let g:languagetool_jar=s:languagetool_dir."/languagetool-commandline.jar"

  " Check/Prepare LanguageTool
  let s:languagetool_v_test=system("cat " . s:languagetool_v_file)
  if s:languagetool_v_test != s:languagetool_version
    echo s:languagetool_v_test
    echo "Preparing LanguageTool..."
    echo "getting " . s:languagetool_download . "..."
    call system("rm -rf " . s:languagetool_dir)
    call system("rm -rf " . s:languagetool_dir . "/*.zip*")
    call system("mkdir -p " . s:languagetool_parent_dir)
    execute "lcd" s:languagetool_parent_dir
    call system("wget " . s:languagetool_download)
    echo "done wget " . s:languagetool_download
    call system("unzip " . s:languagetool_zip )
    call system("rm -f " . s:languagetool_zip)
    call system("printf " . s:languagetool_version . " > " . s:languagetool_v_file)
    lcd -
  endif

  " Other settings
  " If lang is not set, spellang value is used (if it is not set neithr, use en-US).
  "let g:languagetool_lang="en-US"
endif
"}}} LanguageTool

" Excite Translate {{{
" There are translategoogle
call dein#add('mattn/excitetranslate-vim', {
      \ 'depdens': ['mattn/webapi-vim'],
      \ 'on_cmd': ['ExciteTranslate'],
      \ 'lazy': 1})
if s:dein_enabled && dein#tap("excitetranslate-vim")
  xnoremap <Leader>x :ExciteTranslate<CR>
endif
"}}} exciteTranslate


" }}}

" Other tools {{{
" Gmail{{{
NeoBundleLazy "yuratomo/gmail.vim",{
  \ "autoload" : {"commands": ["Gmail"]},
  \ "depends" : ["Shougo/vimproc"]}

if s:neobundle_enable && ! empty(neobundle#get("gmail.vim"))
  let g:gmail_imap = "imap.gmail.com:993"
  let g:gmail_smtp = "smtp.gmail.com:465"
  " path for openssl
  let &path = $path."/usr/bin"
  if filereadable(expand("$HOME/.Gmail.vim"))
    source $HOME/.Gmail.vim
  endif
endif
" }}} Gmail

" SimpleNote{{{
NeoBundleLazy "mattn/vimplenote-vim",{
  \ "autoload" : {"commands": ["VimpleNote"]}}
if s:neobundle_enable && ! empty(neobundle#get("simplenote.vim"))
  " for simplenote.vim
  "let g:SimplenoteUsername = ""
  "let g:SimplenotePassword = """
  if filereadable(expand("$HOME/.Simplenote.vim"))
    source $HOME/.Simplenote.vim
  endif
endif

NeoBundleLazy "mrtazz/simplenote.vim",{
  \ "autoload" : {"commands": ["Simplenote"]}}
if s:neobundle_enable && ! empty(neobundle#get("vimplenote-vim"))
  " for vimplenote-vim
  "let g:VimpleNoteUsername = ""
  "let g:VimpleNotePassword = ""
  " move to $HOME/.VimpleNote
  if filereadable(expand("$HOME/.VimpleNote.vim"))
    " in vimplenote/autoload/vimplenote.vim:get_email(),
    " email must be input even if VimpleNoteUsername was defined,
    " because it checks self.token, it is always 0 here...
    source $HOME/.VimpleNote.vim
  endif
  function! Sn()
    VimpleNote -l
    wincmd w
    wincmd q
  endfunction
endif
" }}} Simplenote

" Evernte {{{
" evernote: need markdown library...
NeoBundleLazy "kakkyz81/evervim",{
  \ "autoload" : {"commands": ["EvervimNotebookList", "EvervimListTags",
  \                            "EvervimSearchByQuery", "EvervimCreateNote",
  \                            "EvervimOpenBrowser", "EvervimSetup"]}}
" }}}

" Google Calendar/Tasks {{{
" Use itchyny/calendar.vim

NeoBundle "mattn/calendar-vim"

" Google Tasks
NeoBundleLazy "mattn/googletasks-vim", {
  \ "depends": "mattn/webapi-vim",
  \ "autoload" : { "commands": ["GoogleTasks"] }}
" }}}

" cloudboard  {{{
NeoBundle "brookhong/cloudboard.vim"
if s:neobundle_enabled && ! empty(neobundle#get("cloudboard.vim"))
  py import vim
  nnoremap <Space>p :CBPut 0<CR>
  vnoremap <Space>y :CBYank 0<CR>
endif
" }}}

" Windows StartMenu {{{
if ( has("win32unix") || has ("win64unix") || has("win32") || has ("win64"))
  NeoBundleLazy "mattn/startmenu-vim", {
        \ "autoload" : { "commands": ["StartMenu"] }}
  NeoBundleLazy "mattn/excelview-vim", {
        \ "depends": "mattn/webapi-vim",
        \ "autoload" : { "commands": ["ExcelView"] }}
endif
" }}}

" Open browser GitHub {{{ not necessary. `hub browse` command is enough to open the current repository in the browser
NeoBundleLazy "tyru/open-browser-github.vim", {
      \ "depends": ["tryu/open-browser.vim"],
      \ "autoload": { "commands" : ["OpenGithubFile","OpenGithubIssue"] }}
" }}}

" vimhelpgenerator {{{
call dein#add('LeafCage/vimhelpgenerator', {
      \ 'on_cmd': ['VimHelpGenerator'],
      \ 'lazy': 1})
" }}}

" calendar.vim {{{
call dein#add('itchyny/calendar.vim', {
      \ 'on_cmd': ['Calendar'],
      \ 'lazy': 1})
if s:dein_enabled && dein#tap("calendar.vim")
  let g:calendar_google_calendar = 1
  let g:calendar_google_task = 1
  let g:calendar_first_day = "sunday"
  let g:calendar_frame = 'default'
  if dein#tap("vim-indent-guides")
    autocmd MyAutoGroup FileType calendar IndentGuidesDisable
  endif
endif
"}}} calendar.vim

" open-browser{{{
" Use netw's gx (enabled as deafult if not set netrw_nogx = 1
" Open browser
call dein#add('tyru/open-browser.vim', {
      \ 'on_map': ['<Plug>(openbrowser-smart-search)'],
      \ 'lazy': 1})

if s:dein_enabled && dein#tap('open-browser.vim')
  let g:netrw_nogx = 1 " disable netrw's gx mapping.
  nmap gx <Plug>(openbrowser-smart-search)
  xmap gx <Plug>(openbrowser-smart-search)
endif
" }}} open-browser

" layoutplugin{{{
" Not use normally
" Plugin template
call dein#add('mopp/layoutplugin.vim', {
      \ 'on_cmd': ['LayoutPlugin'],})
" }}} layoutplugin

" benchvimrc-vim{{{
" Make benchmark result of vimrc
call dein#add('mattn/benchvimrc-vim', {
      \ 'on_cmd': ['BenchVimrc'],
      \ 'lazy': 1})
" }}}

" dbext.vim{{{
" Database access
call dein#add('vim-scripts/dbext.vim')
" }}}
" }}}

" Fun {{{
" Habatobi
NeoBundleLazy "mattn/habatobi-vim",{
      \ "autoload" : {"commands": ["Habatobi"] }}

" flappyvird
NeoBundleLazy "mattn/flappyvird-vim",{
      \ "autoload" : {"commands": ["FlappyVird"] }}

" puyopuyo
NeoBundleLazy "rbtnn/puyo.vim",{
      \ "autoload" : {"commands": ["Puyo"] }}

" rogue {{{
NeoBundleLazy "katono/rogue.vim", {
      \ "autoload" : {"commands": ["Rogue"] }}
if s:dein_enabled && dein#tap("rogue.vim")
  let g:rogue#name = "aaa"
  let g:rogue#directory = s:vimdir . "/rogue"
  let g:rogue#japanese = 1
endif
"}}} rogue

" splash{{{
" show what you like on start-up
NeoBundle "thinca/vim-splash"

if s:neobundle_enable && ! empty(neobundle#get("vim-splash"))
  let g:splash#path = $HOME . "/.vimrc"
endif
"}}} splash

" Funny comment
call dein#add('haya14busa/niconicomment.vim', {
      \ 'on_cmd': ['NiconiComment'],
      \ 'lazy':1 })

" }}}

" }}}

" =========================
" Currenlty, not necessary {{{
" =========================

" Basic Settings {{{
if has("windows")
  scriptencoding cp932 " sjis
  set fileencodings=iso-2022-jp,euc-jp,sjis,utf-8
else " if has("unix") || has("mac")
  set fileencodings=iso-2022-jp,euc-jp,sjis,ucs-bom,default,latin1,utf-8
endif
if has("gui_running") && !has("unix")
  set encoding=utf-8
endif
set encoding=utf8
set encoding=cp932
set fileencodings=iso-2022-jp,euc-jp,sjis,utf-8
set fileencodings=iso-2022-jp,euc-jp,sjis,ucs-bom,default,latin1,utf-8
autocmd MyAutoGroup FileType vbs :set fileencoding=sjis
autocmd MyAutoGroup FileType vbs :set encoding=sjis

" Automatic ime off
" noimdisableactivate was dumped from the latest MacVim?
" noimdisable should be used instead.
" but it seems not necessary anyway (all IME related things are done in KeyRemap4MacBook.
if has("mac")
  set noimdisableactivate
endif

" Set current directory as a directory of the file
autocmd MyAutoGroup BufEnter *   execute ":lcd " . expand("%:p:h")

" INSERT (paste)
set paste " use 'paste at normal mode' in below, instead

" Show line numbers
set number         " Show line numbers
set relativenumber " Relative line number
" }}}

" map (for other than each plugin) {{{
" fix meta-keys which generate <Esc>a .. <Esc>z
let c='a'
while c <= 'z'
  "exec "set <M-".toupper(c).">=\e".c
  "exec "imap \e".c." <M-".toupper(c).">"
  "let c = nr2char(1+char2nr(c))
endw
for i in map(
    \   range(char2nr("a"), char2nr("z"))
    \ + range(char2nr("A"), char2nr("Z"))
    \ + range(char2nr("0"), char2nr("9"))
    \ , "nr2char(v:val)")
  " <ESC>O do not map because used by arrow keys.
  if i != "O"
    execute "nmap <ESC>" . i "<M-" . i . ">"
  endif
endfor

" fix meta-keys each
nmap <ESC>h <M-h>
nmap <ESC>j <M-j>
nmap <ESC>k <M-k>
nmap <ESC>l <M-l>

" Don't use Ex mode, use Q for formatting
map Q gq

""" normal mode (noremap)

" Window move
nnoremap <M-h> <C-w><<CR>
nnoremap <M-j> <C-w>+<CR>
nnoremap <M-k> <C-w>-<CR>
nnoremap <M-l> <C-w>><CR>
nnoremap <D-h> <C-w><<CR>
nnoremap <D-j> <C-w>+<CR>
nnoremap <D-k> <C-w>-<CR>
nnoremap <D-l> <C-w>><CR>

" stop highlight for search
" can't use C-/ ?
nnoremap <C-/> :noh<CR>
" this makes something wrong
" at start when using vim w/o screen...
nnoremap <Esc> :noh<CR>
" Esc mapping may be used others,
" better to use others...
nnoremap <silent> <Esc><Esc> :noh<CR>

" direct indent
" this makes trouble at visual mode (indent twice for current line)
nnoremap > >>
nnoremap < <<

" don't register single letter by x
" * fixed at FileType autocmd
nnoremap x "_x " set in virtualedit

" window
" * not work, because <C-c> cancels the command
nnoremap <C-w><C-c> <C-w><C-c>

" Open vimrc (is <C-u> necessary for command map?
nnoremap <Leader><Leader> :<C-u>tabedit $MYVIMRC<CR>

""" insert mode (inoremap)

" insert file/directory name
" -> Use <C-o><Leader>f, instead
inoremap <silent> <Leader>f <CR><Esc><BS>:r!echo %<CR>i<BS><Esc>Jxi
inoremap <silent> <Leader>f <C-R>%
inoremap <silent> <Leader>d <CR><Esc><BS>:r!echo %:p:h<CR>i<BS><Esc>Jxi

" -> use smartinput
" < can't be used for mapping?
" (maybe < has special means in vim scripts and need special treatment)
inoremap <> <><Left>
inoremap '' ''<Left>
inoremap "" ""<Left>
inoremap () ()<Left>
inoremap [] []<Left>
inoremap {} {}<Left>

inoremap < <><Left>
"inoremap ' ''<Left>
"inoremap " ""<Left>
inoremap ( ()<Left>
inoremap [ []<Left>
inoremap { {}<Left>

""" visual mode (vnoremap)

"  is not necessary?
" -> use to surround
xnoremap { "zdi{<C-R>z}<Esc>
xnoremap [ "zdi[<C-R>z]<Esc>
xnoremap ( "zdi(<C-R>z)<Esc>
xnoremap " "zdi"<C-R>z"<Esc>
xnoremap ' "zdi'<C-R>z'<Esc>

" search: very magic mode
nnoremap / /\v
" to check patterns:
" :h pattern-overview
" }}}

" open .vimrc when starting w/o argument {{{
autocmd VimEnter * nested if @% == "" && s:GetBufByte() == 0 | edit $MYVIMRC | endif
function! s:GetBufByte()
    let byte = line2byte(line("$") + 1)
    if byte == -1
        return 0
    else
        return byte - 1
    endif
endfunction
" }}}

" }}} Currenlty, not necessary

" =============================
" Unused/Obsolete settings {{{
" =============================

" {{{ Basic Settings
" Folding {{{
" Following tow are default
setlocal foldmethod=marker
setlocal foldmarker={{{,}}} "default
" Specific settings are set by plugins
autocmd MyAutoGroup FileType py setlocal foldmethod=syntax
autocmd MyAutoGroup FileType cpp,cxx,C setlocal foldmethod=marker foldmarker={,}

" Save fold and store at leaving insert (make slow)
autocmd MyAutoGroup InsertEnter * if &l:foldmethod ==# 'expr'
      \ | let b:foldinfo = [&l:foldmethod, &l:foldexpr]
      \ | setlocal foldmethod=manual foldexpr=0
      \ | endif
autocmd MyAutoGroup InsertLeave * if exists('b:foldinfo')
      \ | let [&l:foldmethod, &l:foldexpr] = b:foldinfo
      \ | endif
" }}}

" yank share with wviminfo/rviminfo {{{
"
" yankshare prefix
noremap [yshare] <Nop>
map s [yshare]

let g:yankshare_file = get(g:, 'yankshare_file', expand(s:vimdir . '/yankshare.txt'))

function! YSStore() range
  call writefile([getreg('s')], g:yankshare_file, 'b')
endfunction

function! YSLoad() range
  call setreg('s', readfile(g:yankshare_file, 'b')[0])
endfunction

nnoremap <silent> [yshare]y  "syy:call YSStore()<CR>
nnoremap <silent> [yshare]yy "syy:call YSStore()<CR>
nnoremap <silent> [yshare]Y  "sY:call YSStore()<CR>
nnoremap <silent> [yshare]y$ "sy$:call YSStore()<CR>
nnoremap <silent> [yshare]y0 "sy0:call YSStore()<CR>
nnoremap <silent> [yshare]yw "syw:call YSStore()<CR>
nnoremap <silent> [yshare]cc "scc<ESC>:call YSStore()<CR>i
nnoremap <silent> [yshare]C  "sC<ESC>:call YSStore()<CR>i
nnoremap <silent> [yshare]c$ "sc$<ESC>:call YSStore()<CR>i
nnoremap <silent> [yshare]c0 "sc0<ESC>:call YSStore()<CR>i
nnoremap <silent> [yshare]cw "scw<ESC>:call YSStore()<CR>i
nnoremap <silent> [yshare]dd "sdd:call YSStore()<CR>
nnoremap <silent> [yshare]D  "sD:call YSStore()<CR>
nnoremap <silent> [yshare]d$ "sd$:call YSStore()<CR>
nnoremap <silent> [yshare]d0 "sd0:call YSStore()<CR>
nnoremap <silent> [yshare]dw "sdw:call YSStore()<CR>

xnoremap <silent> [yshare]y "sy:call YSStore()<CR>
xnoremap <silent> [yshare]c "sc<ESC>:call YSStore()<CR>i
xnoremap <silent> [yshare]d "sd:call YSStore()<CR>

nnoremap <silent> [yshare]p :call YSLoad()<CR>"sp
nnoremap <silent> [yshare]P :call YSLoad()<CR>"sP
nnoremap <silent> [yshare]gp :call YSLoad()<CR>"sgp
nnoremap <silent> [yshare]gP :call YSLoad()<CR>"sgP
" }}} yankshare

" }}}

" Markdown {{{
" not necessary for current plugins
" Disable highlight italic in Markdown
autocmd MyAutoGroup FileType markdown hi! def link markdownItalic LineNr
" md as markdown, instead of modula2-> should be managed by syntax plugins
" such plasticboy/vim-markdown uses mkd, instead of markdown
autocmd MyAutoGroup BufNewFile,BufRead *.{md,mdwn,mkd,mkdn,mark*} set filetype=markdown
" }}}

" mappings {{{
" for gvim?
nnoremap <silent> "+ "+P
nnoremap <silent> "* "*P

" Surround at Normal mode
" *use surround.vim
nnoremap <Leader>{ bi{<Space><Esc>ea<Space>}<Esc>
nnoremap <Leader>} bi{<Esc>ea}<Esc>
nnoremap <Leader>[ bi[<Space><Esc>ea<Space>]<Esc>
nnoremap <Leader>] bi[<Esc>ea]<Esc>
nnoremap <Leader>( bi(<Space><Esc>ea<Space>)<Esc>
nnoremap <Leader>) bi(<Esc>ea)<Esc>
nnoremap <Leader>< bi<<Space><Esc>ea<Space>><Esc>
nnoremap <Leader>> bi<<Esc>ea><Esc>
nnoremap <Leader>" bi"<Esc>ea"<Esc>
nnoremap <Leader>' bi'<Esc>ea'<Esc>
nnoremap <Leader>` bi`<Esc>ea`<Esc>
" }}}

" Vim Power {{{
" http://vim-jp.org/vim-users-jp/2009/07/10/Hack-39.html
function! Scouter(file, ...)
  let pat = '^\s*$\|^\s*"'
  let lines = readfile(a:file)
  if !a:0 || !a:1
    let lines = split(substitute(join(lines, "\n"), '\n\s*\\', '', 'g'), "\n")
  endif
  return len(filter(lines,'v:val !~ pat'))
endfunction
command! -bar -bang -nargs=? -complete=file Scouter
      \        echo Scouter(empty(<q-args>) ? $MYVIMRC : expand(<q-args>), <bang>0)
command! -bar -bang -nargs=? -complete=file GScouter
      \        echo Scouter(empty(<q-args>) ? $MYGVIMRC : expand(<q-args>), <bang>0)
" }}}


" }}} Unused/Obsolete settings for used plugins

" ==========================================
" Tips {{{
" ==========================================
"" # startup tips
"" * start w/o vimrc
""     vim -u NONE
"" * start w/o viminfo
""     vim -i NONE
"" * start w/o X connection
""     vim -X
"" * write startup timing to startup.log
""     vim --startuptime startup.log
""
"" # check configurations
"" * default commands (mappings)
""     :help index.txt
"" * my mappings
""     :nmap " show mappings for normal mode
"" *show mappings for normal mode with name of file
""  in which the mapping is defined
""     :verbose nmap
"" * for boolean parameters, use '?'
""     :verbose wrap?
""
"" # mapping
"" * leader: default <leader> = \
"" but leader can be changed by
""     let mapleader = ","
"" * special arguments:<silent>,<buffer>, etc...
""     :no a <silent> echo 'hoge'<CR>
"" it doesn't show cmmands/results in command line (so above does nothing)
""     :no a <buffer>... effective in the current buffer only
""
""
"" # Command line
"" * shell command
""     :! echo current file is %
"" % will be replaced by name of current file
""
"" * Insert command result
""     :r ! echo % " insert current file name
""     :r ! echo %:p " full path of file
""     :r ! echo %:h " insert current directory (relative)
""     :r ! echo %:p:h " insert current directory (absolute)
""     :r ! echo expand(%:p:h) " expand such '~'
""     :r !ls "files/directories in current directory
""
""
""
"" # Completion
""     i_C-X_C-F -> file name completion
""     i_C-X_C-K -> dictionary completion
""     i_C-V_tab -> insert tab
""     i_C-R_%   -> insert current file name
""        other C-R usages
""        '"'     the unnamed register, containing the text of
""                the last delete or yank
""        '%'     the current file name
""        '#'     the alternate file name
""        '*'     the clipboard contents (X11: primary selection)
""        '+'     the clipboard contents
""        '/'     the last search pattern
""        ':'     the last command-line
""        '-'     the last small (less than a line) delete
""        '.'     the last inserted text
""                                        *c_CTRL-R_=*
""        '='     the expression register: you are prompted to
""                enter an expression (see |expression|)
""                (doesn't work at the expression prompt; some
""                things such as changing the buffer or current
""
"" # vimdiff (vim -d)
"" * Open files
""     vimdiff file1 file2 [file3 [file4]]
"" * Open vimdiff during editing with vim
""     :vertical diffsplit filename
""     vimdiff file1 file2 [file3 [file4]]
"" * Go to Next Diff
""     [c
"" * Go to Previous Diff
""     ]c
"" * Copy another's buffer's structure to current structure
""     do
"" * Copy current buffer's structure to another structure
""     dp
"" * Diff to original when it was opened
""   :DiffOrig
"" * Stop diff
""   :diffoff
"" * Update diff
""   :diffupdate
""
"" # Register
"" * Show words in register
""     :reg
"" * O thers
""   * Unnamed (") register is used for all copy/delete
""   * 0 register is only used for copy
""   * "0p makes it possible to paste what you copied
""     even after you deleted something
""   * * register is used for clipboard
""   * / is used for word used for searching
""   * "ayy registers current line to register a
""   * "ap copies a register in normal mode
""   * <C-R>" : copy unnamed register in insert mode
""   * <C-R>a : copy a register in insert mode
""
"" # buffer
"" * show buffers
""     :ls
"" * go to next buffer, previous buffer
""     :bn , :bp
"" * go to buffer N
""     :b N or N<C-^>
""
"" # spell check
"" * suggest correct words
""     z=
"" * next missspelled word
""     ]s
"" * previous missspelled word
""     [s
"" * add word under the cursor to good word list file
""     zg
"" * add word under the cursor to good internal-wordlis
""     zG
"" * mark word under the cursor as bad, remove word from good word list file
""     zw
"" * mark word under the cursor as bad, remove word from good internal-wordlist
""     zW
""
"" * undo zg/G/w/W
""    zug/zuG/zuw/zuW
""
"" # undo/redo
"" * show tree
""   :undol[ist]
"" * Go to older/newer
""   g-/g+
"" * Go to older/newer with arguments
""   earlier/later
" }}} Tips

" vim: foldmethod=marker
" vim: foldmarker={{{,}}}
" vim: foldlevel=0
